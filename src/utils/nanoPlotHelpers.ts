import {
  DEFAULT_NANOPLOT_LAYOUT,
  DEFAULT_NANOPLOT_X_TRANSFORM,
  DEFAULT_NANOPLOT_Y_TRANSFORM,
} from '../configs/constants';
import Plotly, { ScatterData } from 'plotly.js-dist-min';

/**
 * A helper function that generates the SVG of a lightcurve "nanoplot"
 * @param plotData a source's most recent observation time v flux data points
 * @returns A stringified SVG generated by a Plotly static plot
 */
export async function getNanoPlotSVG(plotData: {
  time: string[];
  flux: number[];
}) {
  if (!plotData || !plotData.time.length || !plotData.flux.length) {
    return '<span>N/A</span>';
  }

  // Use plotData to construct data for Plotly and then create plotly plot
  const plotlyData = {
    type: 'scatter',
    x: plotData.time.map((t) => new Date(t)),
    y: plotData.flux,
  } as ScatterData;

  const div = document.createElement('div');

  await Plotly.newPlot(div, [plotlyData], DEFAULT_NANOPLOT_LAYOUT);

  // Select the most appropriate SVG element from the plotly plot
  const plotGroup = div.querySelector(
    'g.cartesianlayer > .subplot > .overplot > .xy'
  );

  // Remove the transform from the plotGroup so that it renders within the viewBox
  if (!plotGroup) return '';
  plotGroup.removeAttribute('transform');
  plotGroup.setAttribute(
    'transform',
    `scale(${DEFAULT_NANOPLOT_X_TRANSFORM}, ${DEFAULT_NANOPLOT_Y_TRANSFORM})`
  );

  // Use the default layout dims to calculate an appropriate width/height for the new SVG
  const width =
    (DEFAULT_NANOPLOT_LAYOUT.width / 2 + 50) * DEFAULT_NANOPLOT_X_TRANSFORM;
  const height =
    (DEFAULT_NANOPLOT_LAYOUT.height / 4 + 10) * DEFAULT_NANOPLOT_Y_TRANSFORM;

  const cleanedSvg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
            ${plotGroup.outerHTML}
        </svg>
    `;

  return cleanedSvg;
}
